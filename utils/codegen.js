// utils/codegen.js
// Generate framework-specific code for React, Vue, or plain HTML + CSS.
// Converts extracted HTML/CSS into framework-specific components with proper formatting.

/**
 * Attempt to format code using Prettier if available.
 * Prettier is loaded via CDN in popup.html but may not be available in all contexts.
 * @param {string} code - Raw code to format
 * @param {string} parser - Prettier parser name ('html' or 'babel')
 * @returns {string} Formatted code, or original code if Prettier unavailable/fails
 */
function tryPrettier(code, parser) {
  try {
    // Prettier is loaded via script tags in popup.html and exposed on window
    if (typeof prettier !== "undefined" && prettier.format) {
      // Load appropriate parser plugin
      let plugins = [];
      if (parser === "html") {
        if (typeof prettierPlugins?.html !== "undefined") {
          plugins = [prettierPlugins.html];
        } else if (typeof prettierPlugins?.__global !== "undefined") {
          // Fallback for different Prettier versions
          plugins = [prettierPlugins.__global];
        }
      } else if (parser === "babel") {
        if (typeof prettierPlugins?.babel !== "undefined") {
          plugins = [prettierPlugins.babel];
        } else if (typeof prettierPlugins?.__global !== "undefined") {
          plugins = [prettierPlugins.__global];
        }
      }

      if (plugins.length > 0) {
        return prettier.format(code, {
          parser,
          plugins,
          singleQuote: true,
          printWidth: 80,
          tabWidth: 2,
          useTabs: false,
        });
      }
    }
  } catch (e) {
    console.warn("CRE: Prettier formatting failed:", e);
  }
  return code;
}

/**
 * Convert HTML attributes to JSX-compatible format.
 * Handles class -> className, for -> htmlFor, and other React-specific conversions.
 * @param {string} html - Raw HTML string
 * @returns {string} JSX-compatible HTML string
 */
function htmlToJsx(html) {
  if (!html) return "";
  
  return html
    .replace(/\s+class=/g, " className=") // class -> className
    .replace(/\s+for=/g, " htmlFor=") // for -> htmlFor
    .replace(/\s+tabindex=/g, " tabIndex=") // tabindex -> tabIndex
    .replace(/\s+readonly=/g, " readOnly=") // readonly -> readOnly
    .replace(/checked=""/g, " checked={true}") // checked="" -> checked={true}
    .replace(/selected=""/g, " selected={true}") // selected="" -> selected={true}
    .replace(/<img([^>]*)>/g, (match, attrs) => {
      // Ensure img tags are self-closing
      if (!attrs.trim().endsWith("/")) {
        return `<img${attrs} />`;
      }
      return match;
    })
    .replace(/<br([^>]*)>/gi, "<br$1 />") // <br> -> <br />
    .replace(/<hr([^>]*)>/gi, "<hr$1 />") // <hr> -> <hr />
    .replace(/<input([^>]*)>/gi, (match, attrs) => {
      // Ensure input tags are self-closing
      if (!attrs.trim().endsWith("/")) {
        return `<input${attrs} />`;
      }
      return match;
    });
}

/**
 * Generate a React functional component from extracted HTML/CSS.
 * Converts HTML to JSX and provides a clean component structure with props support.
 * @param {Object} variant - Component variant with html and css
 * @param {string} name - Component name (sanitized for valid JavaScript identifier)
 * @returns {string} React component code
 */
function toReactComponent(variant, name) {
  if (!variant) {
    throw new Error("Variant is required for React code generation");
  }

  // Sanitize component name to valid JavaScript identifier (PascalCase)
  const safeName =
    (name || "MyComponent")
      .replace(/[^a-zA-Z0-9]/g, "")
      .replace(/^[a-z]/, (m) => m.toUpperCase()) || "MyComponent";

  let html = variant.html || "";
  const css = variant.css || "";

  // Convert HTML to JSX
  html = htmlToJsx(html);

  // If HTML contains dangerouslySetInnerHTML candidates, use that instead
  const hasNestedHtml = html.includes("<script") || html.includes("<style");

  let componentCode;
  if (hasNestedHtml) {
    // Use dangerouslySetInnerHTML for content with scripts/styles
    componentCode = `import React from 'react';
import './${safeName}.css';

/**
 * ${safeName} component
 * Generated by Component Remix Engine (CRE)
 * 
 * @param {Object} props - Component props
 * @returns {JSX.Element}
 */
export function ${safeName}(props) {
  const htmlContent = ${JSON.stringify(html)};
  
  return (
    <div className="${safeName.toLowerCase()}-wrapper" dangerouslySetInnerHTML={{ __html: htmlContent }} />
  );
}`;
  } else {
    // Standard JSX embedding
    componentCode = `import React from 'react';
import './${safeName}.css';

/**
 * ${safeName} component
 * Generated by Component Remix Engine (CRE)
 * 
 * @param {Object} props - Component props (extend as needed)
 * @returns {JSX.Element}
 */
export function ${safeName}(props) {
  return (
    <>
${html.split("\n").map((line) => `      ${line}`).join("\n")}
    </>
  );
}`;
  }

  // Add CSS as comment at the end
  if (css) {
    componentCode += `\n\n/*\n * CSS for ${safeName}\n * Copy this to ${safeName}.css:\n */\n/*\n${css}\n*/`;
  }

  // Format with Prettier if available
  return tryPrettier(componentCode.trim(), "babel");
}

/**
 * Generate a Vue 3 Single File Component (SFC) from extracted HTML/CSS.
 * Uses Composition API with <script setup> for modern Vue 3 syntax.
 * @param {Object} variant - Component variant with html and css
 * @param {string} name - Component name (sanitized)
 * @returns {string} Vue SFC code
 */
function toVueSFC(variant, name) {
  if (!variant) {
    throw new Error("Variant is required for Vue code generation");
  }

  // Sanitize component name to valid JavaScript identifier (PascalCase)
  const safeName =
    (name || "MyComponent")
      .replace(/[^a-zA-Z0-9]/g, "")
      .replace(/^[a-z]/, (m) => m.toUpperCase()) || "MyComponent";

  let tpl = variant.html || "";
  const css = variant.css || "";

  // Convert HTML attributes for Vue compatibility
  // class is fine in Vue, but convert v-bind shortcuts
  tpl = tpl.replace(/\s+class=/g, " :class="); // Could use :class for dynamic classes if needed
  
  // Ensure proper indentation for template
  const templateContent = tpl
    .split("\n")
    .map((line) => (line.trim() ? `  ${line.trim()}` : ""))
    .filter((line) => line)
    .join("\n");

  let code = `<template>
${templateContent || "  <div></div>"}
</template>

<script setup lang="ts">
/**
 * ${safeName} component
 * Generated by Component Remix Engine (CRE)
 * 
 * Define props and component logic here
 */

// Example: Define props
// interface Props {
//   // Add your props here
// }
// 
// const props = defineProps<Props>()
</script>

<style scoped>
${css || "/* Add component styles here */"}
</style>`;

  // Format with Prettier if available
  return tryPrettier(code.trim(), "html");
}

/**
 * Generate standalone HTML + CSS code from extracted component.
 * Creates a scoped, self-contained HTML file that can be used directly.
 * @param {Object} variant - Component variant with html and css
 * @param {string} name - Component name (for comments/documentation)
 * @returns {string} HTML + CSS code
 */
function toHtmlCss(variant, name) {
  if (!variant) {
    throw new Error("Variant is required for HTML code generation");
  }

  const html = variant.html || "";
  const css = variant.css || "";
  const componentName = (name || "Component").replace(/[^a-zA-Z0-9\s]/g, "");

  // Create scoped CSS by wrapping in a unique class
  const scopeId = `cre-${componentName.toLowerCase().replace(/\s+/g, "-")}`;
  let scopedCss = css;

  // If CSS contains .cre-component, scope it to our component
  if (css && css.includes(".cre-component")) {
    scopedCss = css.replace(/\.cre-component/g, `.${scopeId}`);
  } else if (css) {
    // Wrap entire CSS in scope
    scopedCss = `.${scopeId} {\n${css.split("\n").map((line) => `  ${line}`).join("\n")}\n}`;
  }

  // Wrap HTML in scoped container
  const scopedHtml = html.includes(`class="${scopeId}"`) || html.includes(`class='${scopeId}'`)
    ? html
    : `<div class="${scopeId}">\n${html.split("\n").map((line) => `  ${line}`).join("\n")}\n</div>`;

  const code = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${componentName}</title>
  <style>
    /* ${componentName} - Generated by Component Remix Engine (CRE) */
${scopedCss.split("\n").map((line) => `    ${line}`).join("\n")}
  </style>
</head>
<body>
  <!-- ${componentName} Component -->
${scopedHtml.split("\n").map((line) => `  ${line}`).join("\n")}
</body>
</html>`;

  // Format with Prettier if available
  return tryPrettier(code.trim(), "html");
}

/**
 * Generate framework-specific code from a component variant.
 * Main entry point for code generation - selects appropriate generator based on framework.
 * 
 * @param {string} framework - Target framework: "react", "vue", or "html"
 * @param {Object} variant - Component variant with {html: string, css: string} properties
 * @param {string} name - Component name (default: "Component")
 * @returns {string} Generated code for the specified framework
 * @throws {Error} If variant is invalid or framework is unsupported
 */
export function generateCodeForFramework(
  framework,
  variant,
  name = "Component"
) {
  // Validate inputs
  if (!variant || typeof variant !== "object") {
    throw new Error("Variant must be an object with html and css properties");
  }

  if (!name || typeof name !== "string") {
    name = "Component";
  }

  // Normalize framework name (case-insensitive)
  const normalizedFramework = (framework || "react").toLowerCase();

  try {
    switch (normalizedFramework) {
      case "vue":
        return toVueSFC(variant, name);
      
      case "html":
      case "html+css":
      case "htmlcss":
        return toHtmlCss(variant, name);
      
      case "react":
      case "jsx":
        return toReactComponent(variant, name);
      
      default:
        console.warn(`CRE: Unknown framework "${framework}", defaulting to React`);
        return toReactComponent(variant, name);
    }
  } catch (error) {
    console.error(`CRE: Code generation failed for ${normalizedFramework}:`, error);
    throw new Error(`Failed to generate ${normalizedFramework} code: ${error.message}`);
  }
}
